# Mzzza
Документация  / Критерии MVP Сроки / Структура и логика проекта / RoadMap / Инфраструктура  / Технологии  / API







/////////Документация 

1 Типовое декларотивное описание програмного продукта
      1. Реализация - размета Markdown   
      2 
      2.
Настоящий документ предназначен для ознакомления пользователя с функциональными возможностями языка разметки Markdown. 
Markdown – это облегченный язык разметки, который является инструментом преобразования кода в HTML.
Главной особенностью данного языка является максимально простой синтаксис, который служит для упрощения написания и чтения кода разметки, что, в свою очередь, позволяет легко его корректировать.
Теперь рассмотрим более подробно функции языка разметки Markdown.   

Markdown не является заменой HTML. Синтаксис Markdown достаточно ограничен, и соответствует лишь небольшому подмножеству элементов HTML. Он включает в себя следующие элементы:

1. Блочные элементы
 + [Параграфы и разрывы строк](#Parag);
 + [Заголовки](#Headers);
 + [Цитаты](#Blockquotes);
 + [Списки](#Lists)
 + [Блоки кода](#CodeBlocks);
 + [Горизонтальные (разделительные) линии](#Lines).
2. Строчные элементы
 + [Ссылки](#Links);
 + [Выделение текста](#Emphasis);
 + [Кодовые фрагменты строк](#Code);
 + [Изображения](#Images).
3. Дополнительные элементы
 + [Обратный слеш](#Backslash Escapes);
 + [Автоматические ссылки](#Automatic Links);
 + [Специальные символы HTML](#SpecialSymbol).  

Более подробно с перечисленными функциями можно ознакомиться в разделе «Описание синтаксиса».

ОПИСАНИЕ СИНТАКСИСА
=========================
   
Блочные элементы
--------------------------  

##### <a name="Parag"></a>	Параграфы и разрывы строк
Для того, чтобы создать параграф с использованием синтаксиса языка Markdown, достаточно отделить строки текста одной (или более) пустой строкой (пустой считается всякая строка, которая не содержит в себе ничего, кроме пробелов и символов табуляции).
Для того, чтобы вставить видимый перенос строки (элемент `<br/>`) необходимо окончить строку двумя пробелами и нажатием клавиши «Enter». 
Многие элементы синтаксиса Markdown выглядят и работают гораздо лучше в случае, когда их форматируют с помощью «жесткого перевода строк» (разделение строк, осуществленное самим пользователем, а не программой автоматически). К таким элементам относятся цитаты, списки и пр.  

##### <a name="Headers"></a> Заголовки  
Язык разметки Markdown поддерживает 2 стиля обозначения заголовков: подчеркивание и выделение символом («#»).
Выделение заголовков с помощью подчеркивания производится знаками равенства («=») в случае, если заголовок первого уровня, и дефисами («-») в случае, если заголовок второго уровня. Количество знаков подчеркивания не ограничивается.
При выделении заголовков с помощью символа («#») используется от одного до шести данных символов, которые устанавливаются в начале строки (перед заголовком). В данном случае количество символов соответствует уровню заголовка. Кроме того, заголовок возможно снабдить закрывающимися символами («#»), хотя это и не является обязательным. Количество закрывающихся символов не обязано соответствовать количеству начальных символов. Уровень заголовка определяется по количеству начальных символов.  
Заголовки первого и второго уровней, выполненные с помощью подчеркивания, выглядят следующим образом:

    Заголовок первого уровня
    ========================
    Заголовок второго уровня
    -------------------------

Заголовки первого, третьего и шестого уровней, выполненные с помощью символа («#»), выглядят следующим образом:
	
    #  Заголовок первого уровня
    ### Заголовок третьего уровня
    ###### Заголовок шестого уровня
Приведенные выше заголовки, выполненные с помощью символа («#») тождественны следующим:

    #  Заголовок первого уровня #
    ### Заголовок третьего уровня ###
    ###### Заголовок шестого уровня ######
В результате на экран выводится следующее:

Заголовок первого уровня
========================

Заголовок второго уровня
------------------------

#  Заголовок первого уровня
### Заголовок третьего уровня
###### Заголовок шестого уровня

##### <a name="Blockquotes"></a> 	Цитаты  
Для обозначения цитат в языке Markdown используется знак «больше» («>»). Его можно вставлять как перед каждой строкой цитаты, так и только перед первой строкой параграфа. 
Также синтаксис Markdown позволяет создавать вложенные цитаты (цитаты внутри цитат). Для их разметки используются дополнительные уровни знаков цитирования («>»).
Цитаты в Markdown могут содержать всевозможные элементы разметки.
Цитаты в языке Markdown выглядят следующим образом:

    >Это пример цитаты,
    >в которой перед каждой строкой
    >ставится угловая скобка.

    >Это пример цитаты,
    в которой угловая скобка
    ставится только перед началом нового параграфа.
    >Второй параграф.

Вложение цитаты в цитату выглядит следующим образом:

    > Первый уровень цитирования
    >> Второй уровень цитирования
    >>> Третий уровень цитирования
    >
    >Первый уровень цитирования
В результате на экран выводится следующее:

>Это пример цитаты,
>в которой перед каждой строкой
>ставится угловая скобка.

>Это пример цитаты,
в которой угловая скобка
ставится только перед началом нового параграфа.

>Второй параграф.

Вложенная цитата:

> Первый уровень цитирования
>> Второй уровень цитирования
>>> Третий уровень цитирования
>
>Первый уровень цитирования


Уровень цитирования не может превышать 15-й.  

##### <a name="Lists"></a> Списки
Markdown поддерживает упорядоченные (нумерованные) и неупорядоченные (ненумерованные) списки.
 Для формирования неупорядоченный списков используются такие маркеры, как звездочки, плюсы и дефисы. Все перечисленные маркеры могут использоваться взаимозаменяемо. 
Для формирования упорядоченных списков в качестве маркеров используются числа с точкой. Важной особенностью в данном случае является то, что сами номера, с помощью которых формируется список, не важны, так как они не оказывают влияния на выходной HTML код. Как бы ни нумеровал пользователь список, на выходе он в любом случае будет иметь упорядоченный список, начинающийся с единицы (1, 2, 3…). Эту особенность стоит учитывать в том случае, когда необходимо использовать порядковые номера элементов в списке, чтобы они соответствовали номерам, получающимся в HTML.
Упорядоченные списки всегда следует начинать с единицы. Маркеры списков обычно начинаются с начала строки, однако они могут быть сдвинуты, но не более чем на 3 пробела. За маркером должен следовать пробел, либо символ табуляции. 
При  необходимости в список можно вставить цитату. В этом случае обозначения цитирования ( «>» ) нужно писать с отступом.
Упорядоченные списки выглядят следующим образом:

    1.	Проводник
    2.	Полупроводник
    3.	Диэлектрик

Неупорядоченные списки выглядят следующим образом:

    * Проводник
    * Полупроводник
    * Диэлектрик

Или

    - Проводник
    - Полупроводник
    - Диэлектрик

Или

    + Проводник
    + Полупроводник
    + Диэлектрик
На выходе всех трех перечисленных вариантов имеется один и тот же результат.
В результате на экран выводится следующее:

1. Проводник
2. Полупроводник
3. Диэлектрик

и

+ Проводник
+ Полупроводник
+ Диэлектрик

Цитата, вставленная в список, выглядит следующим образом:

    1. Элемент списка с цитатой:

        > Это цитата
        > внутри элемента списка.

     2. Второй элемент списка

В результате на экран выводится следующее:

1. Элемент списка с цитатой:

    > Это цитата
    > внутри элемента списка.

2. Второй элемент списка


При вставке цитат в элементы списка важно учитывать, что элементы списка должны находиться на одном уровне, а цитаты должны указываться с отступом. В случае, если правило с единым уровнем списка не соблюдается, следующий после цитаты элемент списка будет автоматически нумероваться цифрой «1.». 
Кроме того, при необходимости в список можно вставить исходный код. В этом случае его нужно писать с двойным отступом – 8 пробелов или 2 символа табуляции. 

 - Элемент списка, содержащий исходный код

		<исходный код >  

##### <a name="CodeBlocks"></a> Блоки кода
Отформатированные блоки кода используются в случае необходимости процитировать исходный код программ или разметки. 
Для создания блока кода в языке Markdown необходимо каждую строку параграфа начинать  с отступа, состоящего из четырех пробелов или  одного символа табуляции. Блок кода продолжается до тех пор, пока не встретится строка без отступа (или конец текста).  Внутри блока кода амперсанды («&») и угловые скобки («<» и «>») автоматически преобразуются в элементы HTML разметки. Кроме того, следует отметить, что внутри блоков кода обычный синтаксис Markdown не обрабатывается. 
Блок кода в Markdown выглядит следующим образом:

Это обычный параграф:

	Это блок кода

##### <a name="Lines">	</a> Горизонтальные линии (разделители)  

Для того чтобы создать горизонтальную линию с использованием синтаксиса языка Markdown, необходимо поместить три (или более)дефиса или звездочки на отдельной строке текста. Между ними возможно располагать пробелы. 
Горизонтальные линии в Markdown выглядят следующим образом:

    Первая часть текста, который необходимо разделить
    ***
    Вторая часть текста, который необходимо разделить

Или

    Первая часть текста, который необходимо разделить

    ---

    Вторая часть текста, который необходимо разделить
В результате на экран выводится следующее:

Первая часть текста, который необходимо разделить
***
Вторая часть текста, который необходимо разделить  

При использовании данного инструмента важно помнить, что после первой части текста и перед второй необходимо оставлять пустую строку. Данное правило необходимо соблюдать только при использовании дефисов. Если его не соблюдать, на экран будет выведен заголовок второго уровня и строка обычного текста.  При использовании символа звездочки данным правилом можно пренебречь.  

 Строчные элементы
-------------------  

##### <a name="Links"></a> Ссылки
Markdown поддерживает два стиля оформления ссылок:

 - Гиперссылка, с немедленным указанием адреса (внутритекстовая);
 - Гиперссылка, подобная сноске.

Подразумевается, что помимо URL-адреса существует еще текст ссылки. Он заключается в квадратные скобки. 
Для создания внутритекстовой гиперссылки необходимо использовать круглые скобки сразу после закрывающей квадратной. Внутри них необходимо поместить URL-адрес. В них же возможно расположить название, заключенное в кавычки, которое будет отображаться при наведении, но этот пункт не является обязательным. 
 
      [пример](http://example.com/ "Необязательная подсказка")
В результате на экран выводится следующее:
[пример](http://example.com/ "Необязательная подсказка")
При ссылке на локальную директорию возможно использование относительного пути (от текущей страницы, сайта и т.п.)  

При создании сносной гиперссылки вместо целевого адреса используется вторая пара квадратных скобок, внутри которых помещается метка, идентификатор ссылки (id).

    [пример][id]:
Также, можно использовать пробел, чтобы отделять 2 пары квадратных скобок: 

    [пример] [id]: 

В этом случае возможно определить идентификатор в любом месте документа: 

    [id]: http://example.com/ "Необязательная подсказка"

В результате на экран выводится следующее:
[пример] [id] 
[id]: http://example.com/ "Необязательная подсказка"
Иными словами, она состоит из следующих элементов:

 - Идентификатор ссылки, окружённый квадратными скобками (которым может предшествовать необязательный отступ от одного до трёх пробелов);
 - 	Двоеточие;
 - 	Один или несколько пробелов (или символов табуляции);
 - 	URL гиперссылки;
 - 	Необязательный заголовок (подсказка к изображению, которая всплывает при наведении на него) гиперссылки, заключённый либо в двойные или одиночные кавычки, либо в скобки.

Идентификаторы ссылок могут состоять из букв, цифр, пробелов и знаков пунктуации, однако они не чувствительны к регистру. То есть эти два варианта эквивалентны:

    [текст ссылки][a]
    [текст ссылки][A]
Markdown позволяет также использовать неявно выраженный идентификатор (сокращенный). В этом случае метка не приводится, вместо неё текст гиперссылки используется  и в качестве её имени, а вторая пара квадратных скобок остаётся пустою.
Например, чтобы сделать слово «Example» гиперссылкой, ведущей на сайт <http://example.com/>, достаточно написать:

    [Example][]
и затем определить гиперссылку:

    [Example]: http://example.com/
В результате на экран выводится следующее:
[Example][]
[Example]: http://example.com/  

##### <a name="Emphasis"></a> 	Выделение текста
Markdown воспринимает звёздочки «*» и символы подчёркивания «_» как признаки смыслового выделения текста:

 - Текст, окружённый одиночными «*» или «_», будет заключен в HTML-тэг `<em>`.
 -  Текст, окружённый двойными «*» или «_», будет заключен в HTML-тэг `<strong>`.

Иными словами, текст, окруженный одинарными символами, выделяется курсивным шрифтом, а текст, окруженный двойными символами, выделяется полужирным шрифтом. 
Также, выделенный фрагмент может находиться в любой части слова. 
Текст, выделенный курсивом с использованием синтаксиса языка Markdown, выглядит следующим образом:

    *Пример*  
*Пример*  

Текст, выделенный полужирным шрифтом с использованием синтаксиса языка Markdown, выглядит следующим образом:

    **Пример**
**Пример**  

Текст, выделенный курсивным полужирным шрифтом с использованием синтаксиса языка Markdown выглядит следующим образом:

    ***Пример***
***Пример***

Все приведенные выше примеры аналогичны следующим:

    _Пример_

    __Пример__

    Пере___распред___деление

    ___Пример___  

##### <a name="Code"></a>	Кодовые фрагменты строк
Чтобы отметить фрагмент строки, содержащий код, необходимо окружить его обратными апострофами «`».  При использовании кодовых фрагментов строк текст будет отображаться в виде моноширинного шрифта. 
В отличие от блоков кода, кодовый фрагмент позволяет поместить код внутрь обычного абзаца текста.
Кодовый фрагмент строки в языке Markdown выглядит следующим образом:

Используйте оператор `if`  

##### <a name="Images"></a>	Изображения
В Markdown существует 2 способа вставки изображений в документ:

a.	С помощью непосредственного указания URL-адреса изображения. Синтаксис данной команды выглядит следующим образом:

    ![Альтернативный текст](/путь/к/изображению.jpg)
или

    ![Альтернативный текст](/путь/к/изображению.jpg "Подсказка")
Иными словами, он состоит из следующих элементов:

 - восклицательный знак;
 -  квадратные скобки, в которых указывается альтернативный изображению текст (он станет содержимым атрибута в элементе img);
 -  круглые скобки, содержащие URL-адрес или относительный путь изображения, а также (необязательно) всплывающую подсказку, заключённуе в двойные или одиночные кавычки.

b.	С помощью метки-идентификатора.  Синтаксис данной команды записывается следующим образом:

    ![Альтернативный текст][id]
где «id» — имя определённой метки изображения. Метки изображений определяются при помощи синтаксиса, совершенно идентичного меткам гиперссылок:

    [id]: путь/к/изображению "Необязательная подсказка"
Важной особенностью является то, что Markdown не позволяет задать размеры изображения (ширину, высоту).  

 Дополнительные элементы
-------------------------  

##### <a name="Backslash Escapes"></a>	Обратный слеш
Может употребляться в Markdown перед специальными символами для того, чтобы они воспринимались в их буквальном (а не служебном) значении. Полный список данных символов приводится ниже:

«\»  - слеш;  

«`»  - обратный апостроф;  

«*»  - звездочка;  

«_»  - символ подчеркивания;  

«{}»  - фигурные скобки;  

«[]»  - квадратные скобки;  

«()»  - круглые скобки;  

«#»  - символ решетки;  

«+»  - плюс;  

«-»  - минус (дефис);  

«.»  – точка;  

«!»  - восклицательный знак.  

##### <a name="Automatic Links"></a> Автоматические ссылки
Markdown поддерживает упрощённый порядок автоматического создания ссылок для URL-адресов и адресов электронной почты. Для этого достаточно поместить URL-адрес или почтовый адрес в угловые скобки, и Markdown сделает его гиперссылкой. В отличие от вышеописанных стилей, в данном случае сам же URL-адрес или почтовый адрес становится и текстом гиперссылки. Автоматические ссылки на адреса электронной почты работают аналогично.
Автоматические ссылки в языке Markdown выглядят следующим образом

    <http://example.com/>
В результате на экран выводится следующее:
<http://example.com/>

Автоматическая ссылка на адрес электронной почты в Markdown выглядит следующим образом

    <address@example.com>
В результате на экран выводится следующее:
<address@example.com>  

##### <a name="SpecialSymbol"></a> Специальные символы HTML
В языке HTML существует два символа, требующих специального рассмотрения: это символы («&lt;») и («&amp;»). Левая угловая скобка используется как начало тэга; амперсанды применяются для обозначения специального символа HTML.
Для того чтобы использовать эти символы в их буквальном смысле, необходимо заменить их элементами HTML, а именно `&lt;` и `&amp;` соответственно.
При использовании Markdown подобных действий совершать не нужно. Он позволяет использовать эти символы в исходном виде. В случае если амперсанд используется как часть спецсимвола HTML, он останется неизменным. В противном случае Markdown преобразует его в `&amp;`. 
<br>
--------<br>



---
    aliases: front matter
---

Заголовок YAML (YAML front matter) — способ хранения файловых метаданных внутри "этого файла".

YAML front matter — это, по сути, раздел текстовых атрибутов, размещенный в самом верху файла. Такой способ был популяризирован статическими генераторами, такими как Jekyll, Hugo и Gatsby. Это один из самых популярных способов поместить метаданные в файл Markdown.

Для создания заголовка YAML нужно поместить его в блок из **тройных дефисов** до и после него. ==Его также нужно разместить в самом верху файла.==

Пример:

```
---
ключ: значение
ключ2: значение2
ключ3: [раз, два, три]
ключ4:
- четыре
- пять
- шесть
---
```

Начиная с версии 0.9.17, заголовок YAML может быть использован для [[Добавление псевдонимов к заметке|добавления псевдонимов к заметке]]. Постепенно мы сделаем его более доступным для разработчиков плагинов и более удобным для пользователя.

В настоящее время поддерживаются три ключа: `tag`, `aliases` и `cssclass`.


 
 
 
 
 
//////////////// 
------------------------
 ///////////////

 
 
 

 
 
 
 
  /////////Критерии MVP Сроки
  
  
  
 
 
 
 
 
 
//////////////// 
------------------------
 ///////////////
 
 
 
 
 


/////////Структура и логика проекта
 
 
 Rust и кроссплатформенная мобильная разработка
Игорь Стеблий
Игорь Стеблий
Следовать

7 мая 2020 г. · 8мин чтения






Недавно я начал исследовать варианты совместного использования бизнес-логики между Android и iOS. Это расследование привело меня к Rust — очень интересному и относительно новому языку программирования, поэтому я решил попробовать.
Что такое ржавчина?
Два самых важных пункта из документации:
Rust невероятно быстр и эффективно использует память: без среды выполнения или сборщика мусора он может поддерживать критически важные для производительности службы, работать на встроенных устройствах и легко интегрироваться с другими языками.
Это язык нативного уровня, такой как C++.
Богатая система типов и модель владения Rust гарантируют безопасность памяти и потокобезопасность, что позволяет устранять многие классы ошибок во время компиляции.
Его компилятор постарается уберечь вас от типичных ошибок памяти.
Это популярно?
Согласно опросу 2019 года , Rust является одним из самых любимых и востребованных среди инженеров ( почему ?) :


источник: https://insights.stackoverflow.com/survey/2019/#technology-_-most-loved-dreaded-and-wanted-languages
Общие тенденции не так велики:

https://insights.stackoverflow.com/trends?tags=rust%2Cgo%2Cc%2B%2B%2Cswift%2Ckotlin
Первое появление языка произошло в 2010 году почти одновременно с Go (2009 год). Версия 1.0 была выпущена в 2015 году, но они по-прежнему добавляют множество новых функций в зависимости от потребностей пользователей.
К сожалению, пока он используется только в нескольких крупных компаниях .
Насколько это хорошо?
Наверное, первое, о чем стоит побеспокоиться, это производительность . Rust, наверное, один из лучших, вот несколько бенчмарков ( слева направо ):
- Rust vs Go;
- Ржавчина против Свифта;
- Ржавчина против С++.




Источник: https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust.html
В среднем он сравним с C/C++ и может быть немного быстрее, чем Swift . Конечно, это зависит от задачи и реализации.
Go или Java обычно на 10 позиций ниже Rust.
Читабельность
Давайте проверим следующий фрагмент кода — реализацию пузырьковой сортировки :



Слева направо: C++, Rust, Swift. Источник https://rosettacode.org/wiki/Sorting_algorithms/Bubble_sort
По синтаксису он близок к Swift;
Это сделано более идиоматично: читабельно и понятно.
Безопасность
Еще одна распространенная проблема C++, которая решается в Rust, — безопасность памяти. Rust гарантирует безопасность памяти во время компиляции и затрудняет (но все же возможно) создание утечки памяти. В то же время он предоставляет богатый набор возможностей для самостоятельного управления памятью — это может быть безопасно или небезопасно .
Мобильный
Я просмотрел официальные примеры из Rust и многих других проектов на GitHub, но они определенно не были близки к реальному варианту использования мобильного приложения. Поэтому было очень сложно оценить сложность реальных проектов или усилия по переходу на Rust. Именно поэтому я решил создать пример, который будет охватывать наиболее важные для меня аспекты:
- нетворкинг;
- многопоточность;
- сериализация данных.
Бэкенд
Для бэкенда, чтобы упростить работу, я решил выбрать StarWars API .
Вы можете создать простой сервер Rust на основе этого официального примера .
Окружающая обстановка
Чтобы настроить среду и создать приложение для IOS и Android, вы можете следовать официальным примерам, они очень подробные и простые:
Ржавчина iOS
Ржавчина Android
Пример Android немного устарел. Если вы используете NDK 20+, вам не нужно создавать собственный набор инструментов, вы можете пропустить этот шаг:
mkdir NDK 
${NDK_HOME}/build/tools/make_standalone_toolchain.py — API 26 — arch arm64 — install-dir NDK/arm64 
${NDK_HOME}/build/tools/make_standalone_toolchain.py — API 26 — arch arm — install-dir NDK /arm 
${NDK_HOME}/build/tools/make_standalone_toolchain.py — API 26 — arch x86 — каталог установки NDK/x86
Вместо этого добавьте пакет NDK и предварительно скомпилированный набор инструментов в PATH:
export NDK_HOME=/Users/$USER/Library/Android/sdk/ndk-bundle 
export PATH=$NDK_HOME/toolchains/llvm/prebuilt/darwin-x86_64/bin:$PATH
И вставьте это cargo-config.toml:
[target.aarch64-linux-android] 
ar = "<NDK_HOME>/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android-ar" 
linker = "<NDK_HOME>/toolchains/llvm/prebuilt/darwin -x86_64/bin/aarch64-linux-android21-clang" 
[target.armv7-linux-androideabi] 
ar = "<NDK_HOME>/toolchains/llvm/prebuilt/darwin-x86_64/bin/arm-linux-androideabi-ar" 
компоновщик = "<NDK_HOME>/toolchains/llvm/prebuilt/darwin-x86_64/bin/armv7a-linux-androideabi21-clang" 
[target.i686-linux-android] 
ar = "<NDK_HOME>/toolchains/llvm/prebuilt/darwin- x86_64/bin/i686-linux-android-ar" 
linker = "<NDK_HOME>/toolchains/llvm/prebuilt/darwin-x86_64/bin/i686-linux-android21-clang"
Многопоточность, HTTP-клиент и десериализация данных
Rust предоставляет довольно надежный API для работы в сети со следующими библиотеками:
Время выполнения Tokio и фреймворк Async/.await
Reqwest — простой HTTP-клиент
Serde — библиотека сериализации/десериализации JSON
Вот пример того, как вы можете объединить их для создания клиента SWAPI ( StarWars API ) с помощью нескольких строк кода:

Клиент StarWars API с Rust
lazy_statlic — макрос для объявления статики с ленивым вычислением.
Коммуникация
Мы подошли к сложной части: взаимодействие между IOS/Android и Rust.
Для этого мы будем использовать FFI . Он использует C-interop для связи и поддерживает только типы, совместимые с C. Связь с C-interop может быть сложной. IOS и Android имеют собственные ограничения и лучшие способы справиться с этим, давайте проверим их один за другим.
Для упрощения передачи данных также можно использовать протоколы передачи байтов: ProtoBuf , FlatBuffer . Оба протокола поддерживают Rust, но я исключаю их из этого упражнения, потому что они снижают производительность.
Андроид
Связь со средой Java осуществляется через экземпляр JNIEnv . Вот простой пример, который возвращает строку обратного вызова в том же потоке:

Обратный вызов Rust FFI Java с JNIEnv
Это выглядит просто, но этот метод имеет ограничение. JNIEnv нельзя просто разделить между потоками, потому что он не реализует трейт `Send` ( trait == protocol/interface ). Если вы поместите call_method в отдельный поток, он завершится с соответствующей ошибкой. Да, вы можете реализовывать Sendсамостоятельно, а также копировать и клонировать , но чтобы избежать шаблонного кода, мы можем использовать rust_swig .
Rust swig основан на тех же принципах, что и SWIG — он использует DSL и генерацию кода, чтобы предоставить вам реализацию. Вот пример псевдокода для Rust SwapiClient, который мы определили ранее:

пример swig_rust для SwapiClient
Помимо оболочки Rust, он также сгенерирует для вас код Java, вот пример автоматически сгенерированного класса SwapiClient:

swig_rust автоматически сгенерированный код для клиента Swapi
Единственное ограничение здесь заключается в том, что вам нужно объявить отдельный метод получения для каждого поля DTO. Хорошо, что это можно было бы объявить внутри DSL. Библиотека имеет богатый список конфигураций, которые вы можете найти в документации .
Также в репозитории rust-swig, android-example, можно найти интеграцию с Gradle .
IOS
Поскольку Swift не требует никакого прокси (например, JNIEnv) для связи с Rust, мы можем использовать FFI напрямую, но, тем не менее, есть много вариантов предоставления доступа к данным:
Предоставьте C-совместимый DTO.
Для каждого DTO вам необходимо создать C-совместимую копию и сопоставить ее перед отправкой в ​​Swift.
Выставить указатель на структуру без каких-либо полей.
Создайте геттер для каждого поля в FFI, который принимает указатель на хост-объект в качестве параметра.
Здесь тоже два возможных варианта:
2.1. метод может returnбыть результатом геттера;
2.2. или вы можете передать указатель для заполнения значением в качестве параметра; (для строки C вам понадобится указатель на начало массива символов и его длину)
Проверим реализацию обоих подходов.
Подход №1

Клиент Swapi и загрузка обратного вызова
На стороне Swift нам нужно будет использовать UnsafePointer и другие варианты необработанного указателя для разворачивания данных:

Обертка Swift для Rust SwapiClient
Здесь будет резонный вопрос: а зачем нам PeopleResponseкласс в swift и соответствующий PeopleCallbackстрайк в swift? В основном, чтобы избежать этого:

Вам нужно отправить объект обратного вызова в нативный код и вернуть его обратно с результатом:

Подход №2
В этом случае мы не будем использовать `PeopleNative`, мы будем использовать оригинальную структуру People из Rust, но мы не будем предоставлять клиенту какое-либо поле, вместо этого мы создадим методы, которые будут принимать указатель на DTO и возвращать требуемый элемент. . Обратите внимание, нам все еще нужно будет обернуть массивы и обратные вызовы, как в предыдущем примере.
Здесь только геттеры, все остальное примерно то же самое:

Геттер Rust SwapiClient для полей
Генерировать заголовки
После того, как вы закончили определение FFI, вы можете сгенерировать заголовок следующим образом:
cargo install cbindgen //установите cbindgen, если у вас его нет 
//сгенерируйте заголовок, который вам нужно включить в проект IOS cbindgen -l C -o src/swapi.h
Также вы можете создать конфигурацию сборки build.rsдля автоматизации этого процесса:

Пример сборки для cbindgen в Rust
Если Android {} иначе IOS {}
Чтобы разделить специфичную для IOS и Android логику, зависимости и т. д., вы можете использовать макросы ( пример ):
#[cfg(target_os="android")]
#[cfg(target_os="ios")]
Самый простой способ разделить задачи — создать отдельный макрос поверх файла — по одному модулю на каждую платформу . Я нашел это немного запутанным, особенно потому, что вы не можете использовать его вbuild.rs , поэтому я отделил специфичную для платформы логику в разных проектах от ядра.


(Слева направо) Как вы можете это сделать и как я это сделал.
Бенчмаркинг
Размер
Оба проекта измерялись только кодом и пользовательским интерфейсом, связанным с Rust.
API отладки Android и общие библиотеки:

API отладки Android и отдельные общие библиотеки МБ
Приложение для отладки IOS и общая библиотека:

отладочное приложение и размер общей библиотеки, МБ
Скорость
Время загрузки автономного решения Rust, его мостов, вызываемых через Android и iOS, а также реализация нативных решений Swift и Kotlin одного и того же сетевого вызова:

измерения времени на стороне клиента после получения обратного вызова с сериализованными данными
Решение для iOS использует URL, URLSession и Codable ;
Android использует сопрограммы с kotlinx.serialization .
Как видите, почти нет разницы между вызовом автономного решения Rust или вызовом его через Andorid&Swift. Это означает, что FFI не создает каких-либо накладных расходов на производительность.
Примечание: скорость запроса сильно зависит от задержки сервера.
Вы можете найти обе реализации в проекте GitHub.
Проект
Полный пример проекта доступен на GitHub:
xajik/rust-кроссплатформенный-мобильный
Кроссплатформенное мобильное решение на базе Rust для IOS и Android. В этом проекте вы найдете сетевой клиент Rust, который…
github.com

Интерфейс iOS и Android


Резюме
Rust — очень многообещающий язык, который дает вам чрезвычайно высокую скорость, заботясь об общих для C++ проблемах с памятью. Надежный и простой API упрощает использование и изучение, среди C++ и Rust я бы определенно выбрал последний, но он все же сложнее, чем Swift или Kotlin.
Самая большая проблема — построить надлежащий мост между Rust и клиентскими фреймворками, если вы можете с этим жить — это может быть отличным решением для мобильных устройств.
Ссылка:
Мое предыдущее расследование: Go + Gomobile для Android и IOS.
Реализация и бенчмаркинг.
 
 
 
 
 
 
 
 
 
 
 
//////////////// 
 Серверная часть+
 ///////////////
 
 Обработчики запросов используют асинхронные функции, которые принимают ноль или более параметров. Эти параметры могут быть извлечены из запроса (см. `FromRequest`Трейт) и возвращают тип, который можно преобразовать в `HttpResponse`(см. `Responder`Трейт):

```rust
use actix_web::{get, post, web, App, HttpResponse, HttpServer, Responder};

#[get("/")]
async fn hello() -> impl Responder {
    HttpResponse::Ok().body("Hello world!")окументация
}

#[post("/echo")]
async fn echo(req_body: String) -> impl Responder {
    HttpResponse::Ok().body(req_body)
}

async fn manual_hello() -> impl Responder {
    HttpResponse::Ok().body("Hey there!")
}
```

Обратите внимание, что к некоторым из этих обработчикhttps://dashboard.heroku.com/ов информация о маршрутизации присоединена напрямую с помощью встроенных макросов. Они позволяют указать метод и путь, на который должен ответить обработчик. Ниже вы увидите, как регистрироваться `manual_hello`(т. Е. Маршруты, не использующие макрос маршрутизации).

Затем создайте `App`экземпляр и зарегистрируйте обработчики запросов. Используется `App::service`для обработчиков, использующих макросы маршрутизации, и `App::route`для обработчиков, маршрутизируемых вручную, с объявлением пути и метода. Наконец, приложение запускается внутри, `HttpServer`которое будет обслуживать входящие запросы, используя вас `App`в качестве «фабрики приложений».








/////////Инфраструктура
 
 
 https://www.oracle.com/cloud/free/
 
 https://dashboard.heroku.com/
 
 
 
 
//////////////// 
----------------------
 ///////////////




/ Технологии  






/ API

Регистрация 

https://partners.gosuslugi.ru/catalog/integration_module

Данные услуги размещены через модуль

Интеграционный модуль упрощает взаимодействие между банками и клиентами и ускоряет бизнес-процессы. Партнеры могут выбрать подходящую услугу, подключиться к системе ЕСИА и запрашивать услуги от имени пользователя.

Что нужно для подключения

Для подключения сервиса потребуется учетная запись физлица — ее можно получить и подтвердить через онлайн-банк. Важно: запись должна быть именно у руководителя, без этого в личном кабинете нельзя будет добавить организацию.

Вам нужна квалифицированная электронная подпись. Ее можно получить в одном из удостоверяющих центров на имя руководителя.

Это делается так: заходите под учетной записью руководителя на Госуслуги, заполняете форму и дожидаетесь окончания проверки. Затем с помощью электронной подписи добавляете профиль организации. Можно заполнить дополнительные поля: например, указать корпоративный транспорт и добавить сотрудников.

Инструкция: как добавить сервис

Шаг 1 из 5

Зарегистрировать информационную систему

Подключите информационную систему к системе межведомственного взаимодействия.

Шаг 2 из 5

Доработать систему

В ЕСИА есть механизм аутентификации пользователей. Он основан на спецификациях OAuth 2.0 и расширении OpenID Connect 1.0. Вам нужно сгенерировать закрытый ключ и сертификат открытого ключа, а после зарегистрировать его в технологическом портале. Подробнее можно прочитать [в разделе 3.1 методических рекомендаций](https://digital.gov.ru/ru/documents/6186/).

Шаг 3 из 5

Отправить заявку на запуск в тестовом режиме

Чтобы сервис работал, нужно время на его проверку. Укажите данные в электронной форме и отправьте ее специалистам

Шаг 4 из 5

Проверить работу тестового запуска

Запустите систему и проверьте, что все работает. Запрос автоматически попадет к специалистам. Если они подтвердят правильность настроек — вы получите доступ к полноценному запуску.https://partners.gosuslugi.ru/catalog/integration_module

Шаг 5 из 5

Отправить заявку на подключение в рабочем режиме

Убедитесь, что все настройки верны. После проверки подайте финальную заявку на запуск сервиса. Как только ее подтвердят, вы сможете пользоваться сервисом из личного кабинета.

Регламенты, инструкции и другие документы

![](https://gu-st.ru/partners-st/assets/svg/icon-docs/doc_any_dark_blue.svg)

Руководство пользователя ЕСИА

![](https://gu-st.ru/partners-st/assets/svg/icon-docs/doc_any_dark_blue.svg)

Руководство пользователя вида сведений «Интеграционный модуль»

![](https://gu-st.ru/partners-st/assets/svg/icon-docs/doc_any_dark_blue.svg)

Заявка на регистрацию Участника и/или информационной системы в СМЭВ 3.0

![](https://gu-st.ru/partners-st/assets/svg/icon-docs/doc_any_dark_blue.svg)

Описание параметров для запроса ИМ

Показать еще

Другие официальные сервисы

![](https://gu-st.ru/content/partners2/icon_vhod_na_gosuslugi.svg)

Вход на сайт через Госуслуги

Ваши клиенты смогут регистрироваться на сайте в один клик - по учетной записи Госуслуг

![](https://gu-st.ru/content/partners2/icon_ediniy_lk.svg)

Единый личный кабинет

Сервис помогает вам поддерживать связь с заявителями через общий личный кабинет
